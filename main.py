# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oYsxz0QrINVaBGT7MCUhQNmVvDMmDZKg
"""

from fastapi import FastAPI
from pydantic import BaseModel
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import joblib
import math

app = FastAPI()

# ==========================================
# 1. تعريف الهيكل الصحيح (TrueChimeraMind)
# ==========================================
# (هذا يجب أن يطابق الكود الذي دربته وحفظته)

class TopologicalCore(nn.Module):
    def __init__(self, num_nodes, input_dim, output_dim):
        super().__init__()
        self.num_nodes = num_nodes
        self.bridge = nn.Linear(input_dim, num_nodes)

        # إعادة بناء القناع (نحتاج لنفس دالة الشكل)
        def _trefoil_knot_positions(n):
            t = torch.linspace(0, 2*math.pi, n)
            x = torch.sin(t) + 2*torch.sin(2*t); y = torch.cos(t) - 2*torch.cos(2*t); z = -torch.sin(3*t)
            return torch.stack([x,y,z], dim=1)

        positions = _trefoil_knot_positions(num_nodes)
        dist_matrix = torch.cdist(positions, positions)
        self.topology_mask = (dist_matrix < 2.5).float() # على CPU

        self.synapses = nn.Linear(num_nodes, num_nodes)
        self.readout = nn.Linear(num_nodes, output_dim)

    def forward(self, x):
        activity = F.elu(self.bridge(x))
        masked_weights = self.synapses.weight * self.topology_mask
        for _ in range(3):
            activity = F.elu(F.linear(activity, masked_weights, self.synapses.bias))
        return self.readout(activity)

class TrueChimeraMind(nn.Module):
    def __init__(self, num_categories, embedding_dim=8):
        super().__init__()
        self.alpha_core = TopologicalCore(num_nodes=32, input_dim=2, output_dim=16)
        self.beta_core = TopologicalCore(num_nodes=64, input_dim=2, output_dim=16)
        self.cat_embedding = nn.Embedding(num_categories, embedding_dim)
        self.gamma_core = nn.Sequential(
            nn.Linear(16 + 16 + embedding_dim, 64),
            nn.LayerNorm(64), nn.GELU(),
            nn.Linear(64, 1), nn.Sigmoid()
        )

    def forward(self, num_x, cat_x):
        alpha_in = num_x[:, [1, 2]]
        beta_in = num_x[:, [0, 3]]
        alpha_thought = self.alpha_core(alpha_in)
        beta_thought = self.beta_core(beta_in)
        cat_context = self.cat_embedding(cat_x)
        gamma_input = torch.cat([alpha_thought, beta_thought, cat_context], dim=1)
        return self.gamma_core(gamma_input)

# ======================================================================
# 2. تحميل النموذج
# ======================================================================
# تحميل Artifacts
artifacts = joblib.load("pricing_artifacts.pkl")
scaler = artifacts['scaler']
le = artifacts['label_encoder']
num_cats = artifacts['num_categories']

# تحميل النموذج
device = "cpu"
model = TrueChimeraMind(num_cats).to(device)
model.load_state_dict(torch.load("chimera_pricing_model.pth", map_location=device))
model.eval()

# ======================================================================
# 3. API Endpoints
# ======================================================================
class PricingRequest(BaseModel):
    avg_price: float
    clicks: int
    duration: float
    category: str

@app.post("/predict_price")
def predict(data: PricingRequest):
    try:
        # البحث عن السعر الأمثل
        # (نفس المنطق السابق، لكن الآن يعمل مع النموذج الصحيح)
        test_prices = np.linspace(data.avg_price * 0.8, data.avg_price * 1.5, 10)
        best_price = data.avg_price
        max_score = -1

        try:
            cat_idx = le.transform([data.category])[0]
        except:
            cat_idx = 0
        t_cat = torch.tensor([cat_idx], dtype=torch.long).to(device)

        results = []
        for price in test_prices:
            # ترتيب المدخلات مهم: [avg_price, click, duration, offered_price]
            raw = np.array([[data.avg_price, data.clicks, data.duration, price]])
            scaled = scaler.transform(raw)
            t_num = torch.tensor(scaled, dtype=torch.float32).to(device)

            with torch.no_grad():
                prob = model(t_num, t_cat).item()

            score = price * prob
            results.append({"price": round(price, 2), "prob": round(prob, 2)})

            if score > max_score:
                max_score = score
                best_price = price

        return {
            "optimal_price": round(best_price, 2),
            "confidence": round(max_score / best_price, 2),
            "analysis": results
        }

    except Exception as e:
        return {"error": str(e)}